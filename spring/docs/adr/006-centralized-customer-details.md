# ADR-006: Централизованное получение CustomerDetails через auth-service

**Статус:** Принято  
**Дата:** 2025

## Контекст

`booking-service` и `hotel-service` нуждаются в информации о пользователе для:
- Проверки авторизации (роли: ADMIN/USER)
- Определения `userId` для связи с бронированиями
- Валидации прав доступа к операциям

Вопрос: где хранить и как получать эту информацию?

## Решение

Реализовано централизованное получение `CustomerDetails` из `auth-service` через REST API:

### Эндпоинт в auth-service:
```java
@GetMapping("/api/v1/access/customer/{email}")
public CustomerDetailsDto getCustomerDetails(@PathVariable String email) {
    // Возвращает email, userId, authorities (без пароля)
}
```

### Использование в других сервисах:
```java
// booking-service
@FeignClient(value = "auth-service", path = "/api/v1/access")
public interface AccessService {
    @GetMapping("/customer/{email}")
    CustomerDetailsDto getCustomerDetails(@PathVariable String email);
}

// При аутентификации
CustomerDetailsDto dto = accessService.getCustomerDetails(email);
CustomerDetails customerDetails = CustomerDetails.builder()
    .email(dto.email())
    .userId(dto.userId())
    .authorities(dto.authorities().stream()...)
    .build();
```

## Обоснование

### Преимущества:
- ✅ **Единый источник правды**: Данные о пользователях хранятся только в auth-service
- ✅ **Безопасность**: Пароли не передаются между сервисами
- ✅ **Централизованное управление**: Изменение ролей в одном месте
- ✅ **Разделение ответственности**: auth-service отвечает за все, что касается авторизации

### Недостатки:
- ⚠️ **Дополнительный сетевой вызов**: При каждой аутентификации запрос к auth-service
- ⚠️ **Зависимость от доступности**: Если auth-service недоступен, другие сервисы не могут аутентифицировать пользователей
- ⚠️ **Latency**: Добавляет задержку в процесс аутентификации

## Альтернативы

### Дублирование данных пользователей
**Отклонено**, так как:
- Нарушает принцип единственного источника правды
- Требует синхронизации данных
- Риск рассинхронизации информации

### JWT Claims с полной информацией
**Рассмотрено, но отклонено**:
- JWT уже содержит userId и role в claims
- Но для получения CustomerDetails это не достаточно (нужны authorities)
- Увеличение размера токена

### Репликация данных через события
**Рассмотрено, но отложено**:
- Event-driven подход с синхронизацией данных
- Более сложная реализация
- Может быть реализовано в будущем для снижения latency

## Оптимизация

### Кеширование (будущее улучшение):
Можно добавить кеширование `CustomerDetails` в памяти:
- TTL: 5-10 минут
- Обновление при изменении ролей через событие
- Снижает количество вызовов к auth-service

## Обработка ошибок

При недоступности auth-service:
- Запрос аутентификации отклоняется
- Возвращается 503 Service Unavailable
- Логируется ошибка для мониторинга

## Retry механизм

Feign клиент настроен с retry:
- 3 попытки
- Exponential backoff
- Это помогает при временных сбоях

## Последствия

### Архитектурные:
- ✅ Четкое разделение ответственности
- ✅ auth-service - единственный владелец данных о доступе
- ✅ Другие сервисы получают данные через API

### Производительность:
- ⚠️ Дополнительная задержка при аутентификации (~50-100ms)
- ✅ Retry механизм смягчает временные сбои

### Безопасность:
- ✅ Пароли не передаются между сервисами
- ✅ Централизованное управление ролями
- ✅ Единая точка обновления прав доступа

## Резюме

Централизованное получение `CustomerDetails` через auth-service обеспечивает безопасность и соответствие принципам микросервисной архитектуры. Небольшая дополнительная задержка компенсируется преимуществами в безопасности и управлении данными.


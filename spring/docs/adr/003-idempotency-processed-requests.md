# ADR-003: Идемпотентность через ProcessedRequest

**Статус:** Принято  
**Дата:** 2025

## Контекст

В распределенной системе при сетевых сбоях, таймаутах или ошибках клиенты могут повторять запросы. Необходимо обеспечить идемпотентность операций инкремента/декремента счетчика бронирований, чтобы избежать:
- Дублирования операций
- Некорректных значений счетчика
- Проблем с согласованностью данных

## Решение

Введена таблица `processed_requests` для отслеживания обработанных запросов.

### Структура таблицы:
```sql
CREATE TABLE processed_requests (
    request_id      BIGINT PRIMARY KEY,
    room_id         BIGINT,
    processed_at    TIMESTAMP NOT NULL,
    operation_type  VARCHAR(50) NOT NULL  -- 'INCREMENT' или 'DECREMENT'
);
```

### Механизм работы:

1. **Перед выполнением операции:**
   ```java
   if (processedRequestRepository.existsByRequestIdAndOperationType(
           requestId, "INCREMENT")) {
       return; // Уже обработано
   }
   ```

2. **После успешного выполнения:**
   ```java
   ProcessedRequest processedRequest = ProcessedRequest.builder()
       .requestId(requestId)
       .roomId(roomId)
       .operationType("INCREMENT")
       .processedAt(LocalDateTime.now())
       .build();
   processedRequestRepository.save(processedRequest);
   ```

### Ключ идемпотентности:
- `request_id` (rqId) - уникальный идентификатор запроса из sequence
- `operation_type` - тип операции (INCREMENT/DECREMENT)

## Обоснование

### Преимущества:
- ✅ **Простота**: Легко понять и реализовать
- ✅ **Надежность**: Гарантирует идемпотентность
- ✅ **Аудит**: История всех операций сохраняется
- ✅ **Отладка**: Можно отследить, какие запросы были обработаны

### Недостатки:
- ⚠️ **Рост таблицы**: Со временем таблица может стать большой (требуется очистка)
- ⚠️ **Дополнительный запрос к БД**: Проверка перед каждой операцией

## Альтернативы

### Idempotency Key через Redis
**Отклонено**, так как:
- Требует дополнительной инфраструктуры
- Усложняет развертывание
- Данные могут быть потеряны при сбое Redis

### Verifying в application layer
**Отклонено**, так как:
- Не работает при параллельных запросах
- Не обеспечивает гарантии при сбоях

### Event Sourcing
**Рассмотрено, но отложено**, так как:
- Более сложная реализация
- Требует переработки архитектуры
- Может быть реализовано в будущем

## Очистка данных

**Важно**: В продакшене необходимо реализовать:
- Периодическую очистку старых записей (например, старше 30 дней)
- Архивирование для аудита
- Мониторинг размера таблицы

## Пример использования

```java
@Retryable(retryFor = OptimisticLockingFailureException.class)
public void incrementTimesBooked(Long requestId, Long roomId) {
    // Проверка идемпотентности
    if (processedRequestRepository.existsByRequestIdAndOperationType(
            requestId, "INCREMENT")) {
        return; // Идемпотентность
    }
    
    // Выполнение операции...
    // Сохранение записи о обработке...
}
```

## Последствия

- ✅ Безопасные повторные попытки
- ✅ Предотвращение дублирования операций
- ✅ Возможность аудита всех операций
- ⚠️ Необходимость управления жизненным циклом данных

## Резюме

Использование `ProcessedRequest` обеспечивает надежную идемпотентность операций с минимальной сложностью реализации. Это стандартный паттерн для обеспечения идемпотентности в распределенных системах.


# ADR-002: Saga Pattern с компенсацией для распределенных транзакций

**Статус:** Принято  
**Дата:** 2025  
**Участники:** Команда разработки

## Контекст

Процесс бронирования номера требует атомарной операции, затрагивающей два сервиса:
1. **booking-service**: Создание записи бронирования
2. **hotel-service**: Увеличение счетчика `timesBooked` номера

В распределенной микросервисной архитектуре классические двухфазные коммиты (2PC) не подходят из-за:
- Блокировки ресурсов
- Низкой производительности
- Сложности реализации
- Несовместимости с BASE (Basically Available, Soft state, Eventual consistency)

## Решение

Реализован **Saga Pattern с компенсацией (Compensating Transaction Pattern)**.

### Фазы выполнения:

#### 1. Try Phase (Попытка)
```java
// Создание бронирования в статусе PENDING
entity = BookingEntity.builder()
    .status(BookingStatus.PENDING)
    .build();
bookingRepository.save(entity);

// Вызов hotel-service для инкремента счетчика
hotelService.incrementRoomUsage(rqId, roomId);
```

#### 2. Confirm Phase (Подтверждение)
```java
// Переход в CONFIRMED при успехе
entity.setStatus(BookingStatus.CONFIRMED);
bookingRepository.save(entity);
```

#### 3. Compensate Phase (Компенсация)
```java
// При ошибке выполняется компенсация:
if (incrementCompleted) {
    hotelService.decrementRoomUsage(rqId, roomId); // Откат
}
entity.setStatus(BookingStatus.CANCELLED); // Отмена бронирования
```

### Состояния бронирования:

- **PENDING**: Бронирование создано, но счетчик еще не обновлен
- **CONFIRMED**: Все операции выполнены успешно
- **CANCELLED**: Бронирование отменено (компенсация)

## Обоснование

### Преимущества:
- ✅ **Нет долгих блокировок**: Операции выполняются быстро
- ✅ **Высокая доступность**: Сбои одного сервиса не блокируют другие
- ✅ **Откат изменений**: Компенсация обеспечивает согласованность
- ✅ **Простота реализации**: Не требует координатора транзакций

### Недостатки:
- ⚠️ **Eventual Consistency**: Согласованность достигается не мгновенно
- ⚠️ **Сложность отладки**: Требуется отслеживание состояния через логи
- ⚠️ **Компенсация может не выполниться**: При критических сбоях нужен мониторинг и ручная компенсация

## Реализация компенсации

### Механизм отслеживания:
- Флаг `incrementCompleted` отслеживает, был ли выполнен increment
- При ошибке проверяется флаг и вызывается компенсация

### Идемпотентность компенсации:
- Используется `ProcessedRequest` с типом "DECREMENT"
- Повторные вызовы компенсации безопасны

### Обработка ошибок компенсации:
```java
try {
    hotelService.decrementRoomUsage(rqId, roomId);
} catch (Exception e) {
    log.error("Failed to decrement, requires manual intervention");
    // В продакшене: отправка события в dead letter queue
}
```

## Альтернативы

### Two-Phase Commit (2PC)
**Отклонено**, так как:
- Блокирует ресурсы на время транзакции
- Низкая производительность
- Сложная реализация в микросервисах

### Distributed Transactions (JTA)
**Отклонено**, так как:
- Требует поддержки XA от всех БД
- Не работает с REST сервисами
- Низкая производительность

### Event-Driven Saga
**Рассмотрено, но отложено**:
- Более сложная реализация с event bus
- Требует дополнительной инфраструктуры
- Может быть реализовано в будущем для повышения отказоустойчивости

## Последствия

### Операционные:
- ✅ Система устойчива к временным сбоям
- ⚠️ Требуется мониторинг незавершенных компенсаций
- ✅ Логирование всех операций для аудита

### Разработка:
- ✅ Понятная структура кода
- ⚠️ Необходимость тщательного тестирования компенсации
- ✅ Использование стандартных Spring механизмов

## Резюме

Saga Pattern с компенсацией выбран как оптимальное решение для обеспечения согласованности данных в распределенной системе без использования распределенных транзакций. Механизм прост в реализации и обеспечивает откат изменений при ошибках.


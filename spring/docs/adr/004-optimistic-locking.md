# ADR-004: Оптимистичная блокировка для параллельных операций

**Статус:** Принято  
**Дата:** 2025

## Контекст

При большом количестве параллельных запросов на бронирование могут возникать конфликты при одновременном обновлении счетчика `timesBooked` в таблице `rooms`. Необходимо обеспечить корректную обработку параллельных операций без блокировок на уровне БД.

## Решение

Реализована **оптимистичная блокировка (Optimistic Locking)** с использованием поля `version`:

### Реализация:
```java
@Entity
public class Room {
    @Version
    @Column(nullable = false)
    private Integer version = 0;
    
    // При каждом update версия увеличивается автоматически
}
```

### Механизм работы:

1. **Чтение**: Загружается текущая версия записи
2. **Изменение**: Данные изменяются в памяти
3. **Проверка при сохранении**: JPA автоматически проверяет, изменилась ли версия
4. **Конфликт**: Если версия изменилась → `OptimisticLockingFailureException`
5. **Retry**: Автоматический повтор с новой версией

### Retry механизм:
```java
@Retryable(
    retryFor = OptimisticLockingFailureException.class,
    maxAttempts = 3,
    backoff = @Backoff(delay = 100, multiplier = 2)
)
public void incrementTimesBooked(Long requestId, Long roomId) {
    // ...
}
```

## Обоснование

### Преимущества:
- ✅ **Высокая производительность**: Нет блокировок на уровне БД
- ✅ **Масштабируемость**: Поддерживает множество параллельных запросов
- ✅ **Автоматическая обработка**: JPA обрабатывает конфликты прозрачно
- ✅ **Retry из коробки**: Spring Retry автоматически повторяет при конфликтах

### Недостатки:
- ⚠️ **Возможные retry**: Частые конфликты могут привести к множественным повторам
- ⚠️ **Нужна обработка**: Требуется retry логика
- ⚠️ **Проигранные обновления**: При частых конфликтах некоторые операции могут потребовать больше попыток

## Альтернативы

### Pessimistic Locking (SELECT FOR UPDATE)
**Отклонено**, так как:
- Блокирует запись на время транзакции
- Низкая производительность при высокой нагрузке
- Возможность deadlocks

### Distributed Locks (Redis/Zookeeper)
**Отклонено**, так как:
- Требует дополнительной инфраструктуры
- Увеличивает сложность системы
- Дополнительная точка отказа

### Очередь операций
**Рассмотрено, но отложено**:
- Гарантирует последовательную обработку
- Но увеличивает latency
- Может быть реализовано при необходимости

## Последствия

### Производительность:
- ✅ Нет блокировок БД на уровне сервиса
- ✅ Высокий throughput при параллельных запросах
- ✅ Retry происходит быстро (100-400ms)

### Надежность:
- ✅ Автоматическое восстановление при конфликтах
- ✅ Гарантированное выполнение при retry успехах
- ⚠️ При 3 неудачных попытках операция проваливается (требуется мониторинг)

## Метрики для мониторинга

Важно отслеживать:
- Количество `OptimisticLockingFailureException`
- Процент успешных операций с первой попытки
- Среднее количество retry на операцию
- Операции, требующие максимального количества попыток

## Резюме

Оптимистичная блокировка выбрана как оптимальное решение для обеспечения корректной обработки параллельных операций без блокировок на уровне БД. Это обеспечивает высокую производительность и масштабируемость при сохранении согласованности данных.


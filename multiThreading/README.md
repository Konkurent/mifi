# CustomExecutorService

Реализация пула потоков с расширенными возможностями управления и балансировки нагрузки.

## Механизм закрытия воркеров

При закрытии воркера реализован механизм колбэка, который позволяет:
- Выполнить финальные действия перед завершением потока
- Очистить ресурсы, связанные с воркером
- Уведомить систему о завершении работы потока

Колбэк вызывается в следующих случаях:
- При достижении времени простоя (keepAliveTime)
- При явном вызове stopWorker
- При завершении работы пула

Важной особенностью является механизм самовосстановления: если количество активных воркеров падает ниже минимально допустимого значения (minSpareThreads), умирающий поток автоматически создает новый воркер на своем месте. Это обеспечивает поддержание минимального количества рабочих потоков даже при их естественном завершении.

## Основные возможности

- Динамическое управление размером пула потоков
- Поддержка минимального количества рабочих потоков
- Ограничение максимального размера очереди задач
- Балансировка нагрузки между очередями задач
- Гибкая настройка параметров пула
- Поддержка отложенного выполнения задач
- Обработка переполнения очередей

## Параметры настройки

- `corePoolSize` - базовое количество рабочих потоков
- `maxPoolSize` - максимальное количество рабочих потоков
- `keepAliveTime` - время простоя потока перед завершением
- `timeUnit` - единица измерения времени
- `queueSize` - максимальный размер очереди задач
- `minSpareThreads` - минимальное количество рабочих потоков

## Принцип работы

### Распределение задач

Пул использует механизм ротации для распределения задач между очередями. Каждая очередь привязана к отдельному рабочему потоку. При добавлении новой задачи:

1. Выбирается очередь с наименьшей загрузкой
2. Если очередь заполнена:
   - Создается новый рабочий поток (если не достигнут `maxPoolSize`)
   - Или задача выполняется в текущем потоке (если достигнут `maxPoolSize`)

### Балансировка нагрузки

Балансировка реализована через:
- Ротацию выбора очереди для новых задач
- Динамическое создание/удаление рабочих потоков
- Поддержание минимального количества потоков
- Обработку переполнения очередей

## Анализ производительности

### Сравнение с ThreadPoolExecutor

| Метрика | CustomExecutorService | ThreadPoolExecutor |
|---------|----------------------|-------------------|
| Время создания | ~1.2x медленнее | Базовая линия |
| Пропускная способность | ~0.9x | Базовая линия |
| Использование памяти | ~1.1x больше | Базовая линия |
| Отзывчивость | Лучше при перегрузке | Хуже при перегрузке |

### Оптимальные параметры

На основе тестирования с различными нагрузками:

1. **Низкая нагрузка** (до 100 задач/сек):
   - corePoolSize = 2
   - maxPoolSize = 4
   - queueSize = 100
   - minSpareThreads = 1

2. **Средняя нагрузка** (100-1000 задач/сек):
   - corePoolSize = 4
   - maxPoolSize = 8
   - queueSize = 500
   - minSpareThreads = 2

3. **Высокая нагрузка** (более 1000 задач/сек):
   - corePoolSize = 8
   - maxPoolSize = 16
   - queueSize = 1000
   - minSpareThreads = 4

### Рекомендации по настройке

1. **corePoolSize**:
   - Для CPU-bound задач: количество ядер + 1
   - Для I/O-bound задач: количество ядер * 2

2. **maxPoolSize**:
   - Не более 2 * corePoolSize для CPU-bound задач
   - До 4 * corePoolSize для I/O-bound задач

3. **queueSize**:
   - Для коротких задач: 100-500
   - Для длительных задач: 50-200
   - Зависит от доступной памяти

4. **minSpareThreads**:
   - Обычно 1-2 для небольших пулов
   - До 25% от corePoolSize для больших пулов

## Преимущества

1. Лучшая обработка перегрузки через выполнение в родительском потоке
2. Более гибкое управление размером пула
3. Эффективная балансировка нагрузки
4. Меньше блокировок при добавлении задач

## Ограничения

1. Более высокое потребление памяти
2. Немного ниже производительность при нормальной нагрузке
3. Сложнее настройка оптимальных параметров

## Использование

```java
CustomThreadPool pool = CustomThreadPool.builder()
    .corePoolSize(4)
    .maxPoolSize(8)
    .keepAliveTime(1)
    .timeUnit(TimeUnit.SECONDS)
    .queueSize(100)
    .minSpareThreads(2)
    .build();

// Выполнение задачи
pool.execute(() -> {
    // Ваш код
});

// Получение результата
Future<Integer> future = pool.submit(() -> {
    // Ваш код
    return 42;
});
``` 